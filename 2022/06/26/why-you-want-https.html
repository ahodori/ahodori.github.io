<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Why you want HTTPS | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Why you want HTTPS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="So let’s say you just made a cool app, and now you want to put it on the internet for people to use. Here’s why if you’re going to accept user data, you really, really should be using HTTPS. Reason 1: Why HTTP alone is dangerous Let’s say that on your app, a user makes a request to log in. What actually happens on the internet to make that happen? The internet works as a series of connections that relay requests between the two endpoints. Your computer connects to your router, and sends the request there; the router sees from the headers that it is not the final destination, so it sends it along to your ISP. Your ISP is not the final destination either, and from there the request could either be sent back down to a router or to another ISP altogether if the receiving domain is not using the same one. This may not be a very precise picture of the path traced by a request, but the point is that it can get very complicated, and most importantly involve relay points you know nothing about. If one of those relay points is compromised by an attacker (for instance, an unsecured public WiFi access point) they will be able to read and modify any requests you send. Now, you may ask, what’s the big deal with that? I’m not storing passwords in plain text, I’m encrypting them. But you encrypt them on the back end, not the front. In a normal HTTP request, until that password reaches the server, it’s in plaintext form within the HTTP body and anyone who can intercept the HTTP request can read it. And encrypting on the front-end is hard to do: In addition to sourcing your own cryptographic algorithm, you have to think about how you can keep it secure when the algorithm is being delivered to any end user as part of the web page. Even if an algorithm can’t be completely beaten by seeing what is sent, it will give attackers a good indication as to its weaknesses. An attacker doesn’t need all the information; anything that narrows down the possibilities means a brute-force attack will take that much less time. Reason 2: It’s not that much more The full name of HTTPS is HTTP over SSL/TLS: What that means is that HTTP and HTTPS are actually the same format. HTTPS adds its extra layer of security by simply routing HTTP requests through an SSL/TLS connection, which is encrypted. What this means is that, if the certificates are set up correctly, there’s no extra step in writing your own code; the existing infrastructure gives you everything you need. Just change the http:// in a link to https://. Note that when using Javascript there might be a difference in the “credentials” option in the fetch options object. If your server being fetched to is on the same domain as the page doing the fetching, you can leave that setting as ‘same-origin’; the alternative ‘include’ for fetches made to other domains is a little more complicated, so I’ll leave that for later. SSL and its successor TLS are technologies operating on about the same level as HTTP. TLS provides good encryption, but depends on the server having a certificate issued by a trusted authority. That might sound like a lot, but it’s not too bad. Extensive campaigning for HTTPS everywhere in the 2010s has improved both the adoption and availability of TLS certificates. There are websites where you can buy one for about 30 dollars, but there are also projects like Let’s Encrypt, a nonprofit trying to spread HTTPS on the web by offering certificates for free. Let’s Encrypt has an automated process that can get you a 90-day TLS certificate. And, again, once you have it set up, it’s as simple as making https:// requests instead of http:// on the front end. On the back end, the current Heroku as of 2022 allows you to simply add a certificate with the command heroku certs:add server.crt server.key where server.crt and server.key are the certificate and private key pair you recieve by registering a certificate. Everything else should work by default." />
<meta property="og:description" content="So let’s say you just made a cool app, and now you want to put it on the internet for people to use. Here’s why if you’re going to accept user data, you really, really should be using HTTPS. Reason 1: Why HTTP alone is dangerous Let’s say that on your app, a user makes a request to log in. What actually happens on the internet to make that happen? The internet works as a series of connections that relay requests between the two endpoints. Your computer connects to your router, and sends the request there; the router sees from the headers that it is not the final destination, so it sends it along to your ISP. Your ISP is not the final destination either, and from there the request could either be sent back down to a router or to another ISP altogether if the receiving domain is not using the same one. This may not be a very precise picture of the path traced by a request, but the point is that it can get very complicated, and most importantly involve relay points you know nothing about. If one of those relay points is compromised by an attacker (for instance, an unsecured public WiFi access point) they will be able to read and modify any requests you send. Now, you may ask, what’s the big deal with that? I’m not storing passwords in plain text, I’m encrypting them. But you encrypt them on the back end, not the front. In a normal HTTP request, until that password reaches the server, it’s in plaintext form within the HTTP body and anyone who can intercept the HTTP request can read it. And encrypting on the front-end is hard to do: In addition to sourcing your own cryptographic algorithm, you have to think about how you can keep it secure when the algorithm is being delivered to any end user as part of the web page. Even if an algorithm can’t be completely beaten by seeing what is sent, it will give attackers a good indication as to its weaknesses. An attacker doesn’t need all the information; anything that narrows down the possibilities means a brute-force attack will take that much less time. Reason 2: It’s not that much more The full name of HTTPS is HTTP over SSL/TLS: What that means is that HTTP and HTTPS are actually the same format. HTTPS adds its extra layer of security by simply routing HTTP requests through an SSL/TLS connection, which is encrypted. What this means is that, if the certificates are set up correctly, there’s no extra step in writing your own code; the existing infrastructure gives you everything you need. Just change the http:// in a link to https://. Note that when using Javascript there might be a difference in the “credentials” option in the fetch options object. If your server being fetched to is on the same domain as the page doing the fetching, you can leave that setting as ‘same-origin’; the alternative ‘include’ for fetches made to other domains is a little more complicated, so I’ll leave that for later. SSL and its successor TLS are technologies operating on about the same level as HTTP. TLS provides good encryption, but depends on the server having a certificate issued by a trusted authority. That might sound like a lot, but it’s not too bad. Extensive campaigning for HTTPS everywhere in the 2010s has improved both the adoption and availability of TLS certificates. There are websites where you can buy one for about 30 dollars, but there are also projects like Let’s Encrypt, a nonprofit trying to spread HTTPS on the web by offering certificates for free. Let’s Encrypt has an automated process that can get you a 90-day TLS certificate. And, again, once you have it set up, it’s as simple as making https:// requests instead of http:// on the front end. On the back end, the current Heroku as of 2022 allows you to simply add a certificate with the command heroku certs:add server.crt server.key where server.crt and server.key are the certificate and private key pair you recieve by registering a certificate. Everything else should work by default." />
<link rel="canonical" href="/2022/06/26/why-you-want-https.html" />
<meta property="og:url" content="/2022/06/26/why-you-want-https.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-26T16:39:01-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Why you want HTTPS" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-26T16:39:01-04:00","datePublished":"2022-06-26T16:39:01-04:00","description":"So let’s say you just made a cool app, and now you want to put it on the internet for people to use. Here’s why if you’re going to accept user data, you really, really should be using HTTPS. Reason 1: Why HTTP alone is dangerous Let’s say that on your app, a user makes a request to log in. What actually happens on the internet to make that happen? The internet works as a series of connections that relay requests between the two endpoints. Your computer connects to your router, and sends the request there; the router sees from the headers that it is not the final destination, so it sends it along to your ISP. Your ISP is not the final destination either, and from there the request could either be sent back down to a router or to another ISP altogether if the receiving domain is not using the same one. This may not be a very precise picture of the path traced by a request, but the point is that it can get very complicated, and most importantly involve relay points you know nothing about. If one of those relay points is compromised by an attacker (for instance, an unsecured public WiFi access point) they will be able to read and modify any requests you send. Now, you may ask, what’s the big deal with that? I’m not storing passwords in plain text, I’m encrypting them. But you encrypt them on the back end, not the front. In a normal HTTP request, until that password reaches the server, it’s in plaintext form within the HTTP body and anyone who can intercept the HTTP request can read it. And encrypting on the front-end is hard to do: In addition to sourcing your own cryptographic algorithm, you have to think about how you can keep it secure when the algorithm is being delivered to any end user as part of the web page. Even if an algorithm can’t be completely beaten by seeing what is sent, it will give attackers a good indication as to its weaknesses. An attacker doesn’t need all the information; anything that narrows down the possibilities means a brute-force attack will take that much less time. Reason 2: It’s not that much more The full name of HTTPS is HTTP over SSL/TLS: What that means is that HTTP and HTTPS are actually the same format. HTTPS adds its extra layer of security by simply routing HTTP requests through an SSL/TLS connection, which is encrypted. What this means is that, if the certificates are set up correctly, there’s no extra step in writing your own code; the existing infrastructure gives you everything you need. Just change the http:// in a link to https://. Note that when using Javascript there might be a difference in the “credentials” option in the fetch options object. If your server being fetched to is on the same domain as the page doing the fetching, you can leave that setting as ‘same-origin’; the alternative ‘include’ for fetches made to other domains is a little more complicated, so I’ll leave that for later. SSL and its successor TLS are technologies operating on about the same level as HTTP. TLS provides good encryption, but depends on the server having a certificate issued by a trusted authority. That might sound like a lot, but it’s not too bad. Extensive campaigning for HTTPS everywhere in the 2010s has improved both the adoption and availability of TLS certificates. There are websites where you can buy one for about 30 dollars, but there are also projects like Let’s Encrypt, a nonprofit trying to spread HTTPS on the web by offering certificates for free. Let’s Encrypt has an automated process that can get you a 90-day TLS certificate. And, again, once you have it set up, it’s as simple as making https:// requests instead of http:// on the front end. On the back end, the current Heroku as of 2022 allows you to simply add a certificate with the command heroku certs:add server.crt server.key where server.crt and server.key are the certificate and private key pair you recieve by registering a certificate. Everything else should work by default.","headline":"Why you want HTTPS","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/06/26/why-you-want-https.html"},"url":"/2022/06/26/why-you-want-https.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Why you want HTTPS</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-06-26T16:39:01-04:00" itemprop="datePublished">Jun 26, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>So let’s say you just made a cool app, and now you want to put it on the internet for people to use.</p>

<p>Here’s why if you’re going to accept user data, you really, really should be using HTTPS.</p>

<h2 id="reason-1-why-http-alone-is-dangerous">Reason 1: Why HTTP alone is dangerous</h2>
<p>Let’s say that on your app, a user makes a request to log in. What actually happens on the internet to make that happen?</p>

<p>The internet works as a series of connections that relay requests between the two endpoints. Your computer connects to your router, and sends the request there; the router sees from the headers that it is not the final destination, so it sends it along to your ISP. Your ISP is not the final destination either, and from there the request could either be sent back down to a router or to another ISP altogether if the receiving domain is not using the same one. This may not be a very precise picture of the path traced by a request, but the point is that it can get very complicated, and most importantly involve relay points you know nothing about. If one of those relay points is compromised by an attacker (for instance, an unsecured public WiFi access point) they will be able to read and modify any requests you send.</p>

<p>Now, you may ask, what’s the big deal with that? I’m not storing passwords in plain text, I’m encrypting them.</p>

<p>But you encrypt them on the back end, not the front. In a normal HTTP request, until that password reaches the server, it’s in plaintext form within the HTTP body and anyone who can intercept the HTTP request can read it.</p>

<p>And encrypting on the front-end is hard to do: In addition to sourcing your own cryptographic algorithm, you have to think about how you can keep it secure when the algorithm is being delivered to any end user as part of the web page. Even if an algorithm can’t be completely beaten by seeing what is sent, it will give attackers a good indication as to its weaknesses. An attacker doesn’t need all the information; anything that narrows down the possibilities means a brute-force attack will take that much less time.</p>

<h2 id="reason-2-its-not-that-much-more">Reason 2: It’s not that much more</h2>

<p>The full name of HTTPS is HTTP over SSL/TLS: What that means is that HTTP and HTTPS are actually the same format. HTTPS adds its extra layer of security by simply routing HTTP requests through an SSL/TLS connection, which is encrypted. What this means is that, if the certificates are set up correctly, there’s no extra step in writing your own code; the existing infrastructure gives you everything you need. Just change the http:// in a link to https://.</p>

<p>Note that when using Javascript there might be a difference in the “credentials” option in the fetch options object. If your server being fetched to is on the same domain as the page doing the fetching, you can leave that setting as ‘same-origin’; the alternative ‘include’ for fetches made to other domains is a little more complicated, so I’ll leave that for later.</p>

<p>SSL and its successor TLS are technologies operating on about the same level as HTTP. TLS provides good encryption, but depends on the server having a certificate issued by a trusted authority. That might sound like a lot, but it’s not too bad.</p>

<p>Extensive campaigning for HTTPS everywhere in the 2010s has improved both the adoption and availability of TLS certificates. There are websites where you can buy one for about 30 dollars, but there are also projects like Let’s Encrypt, a nonprofit trying to spread HTTPS on the web by offering certificates for free. Let’s Encrypt has an automated process that can get you a 90-day TLS certificate. And, again, once you have it set up, it’s as simple as making https:// requests instead of http:// on the front end.</p>

<p>On the back end, the current Heroku as of 2022 allows you to simply add a certificate with the command
<code class="language-plaintext highlighter-rouge">heroku certs:add server.crt server.key</code>
where server.crt and server.key are the certificate and private key pair you recieve by registering a certificate. Everything else should work by default.</p>

  </div><a class="u-url" href="/2022/06/26/why-you-want-https.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
